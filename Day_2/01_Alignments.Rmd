---
title: "Fall Into Bioinformatics"
subtitle: "Alignment Quality Control"
author: "Jimmy Breen"
date: "17/09/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
    echo = TRUE,
    message = FALSE,
    warning = FALSE,
    fig.align = "center",
    results = "hide"
)
if (interactive()) setwd(here::here("Day_1"))
```

* TOC
{:toc}

## Welcome

Welcome to Spring Into Bioinformatics for 2019.
Over this 3 day course we'll hopefully cover enough concepts to get you started with your data and analyses.
This course will provide the most benefit if you continue to use the skills in the weeks directly after the course, and is aimed at those with minimal to no prior bioinformatics expertise.
Course material will be available at this URL indefinitely.

Most of the sessions will be self-guided, with key direction provided sporadically at important times.
Please ask as many questions as you'd like.
The tutors are specifically here to help you understand & develop your skills, so please ensure you take full advantage of their availability.

We strongly encourage you to a) read all of the notes, and b) manually type **all of the code** (unless directed otherwise).
This will provide you with the the most benefit.


### Tutors

This course was primarily written by members of the Bioinformatics Hub and the tutors across the three days will be:

- Nathan Watson-Haigh, Dan Kortschak & Mark Armstrong (Bioinformatics Hub Staff)
- Jimmy Breen (Bioinformatics Hub / SAHMRI)
- Nhi Hin (PhD Candidate, Bioinformatics Hub)
- Melanie Smith (PhD Candidate, Robinson Research Institute)
- Terry Bertozzi (SA Museum)

## Day 2: Working with alignments and differential expression

```{r loadPackages, echo=FALSE, eval=TRUE}
library(tidyverse)
library(limma)
library(ggrepel)
library(pander)
library(RColorBrewer)
library(reshape2)
library(scales)
library(pheatmap)
library(VennDiagram)
library(edgeR)
library(DiagrammeR)
theme_set(theme_bw())
```

In keeping with the format of this course where we essentially started at the end and worked our way forward, the the last Day we are going to learn the initial steps needed to process high-throughput sequencing data. 
In Day 1 we learnt how to analyse and organise data in `R`, use important data processing packages contained in the `tidyverse` ecosystem, and perform plots that you would commonly create for Transcriptome sequencing projects (e.g. Volcano plot, Mean-difference plot etc). 
Today we are going learn how to quantify aligned data and create a gene counts table, run common functions to assess sample and project quality (unsupervised clustering and estimation of library sizes) and perform differential expression analyses.

## Today's Schedule

- A quick introduction to `bash` and setting up the VM
- Working with Alignments
  - Quality control of alignment data
  - Duplication/Deduplication with Picard
  - Assessment of alignment rate and multi-mapping

- Gene quantification and counts
  - Summarisation of aligned data to counts
  - Quality control of samples based on mapping counts
  - Estimation of library sizes
  - PCA/MDS assessment of outliers and batch effects

- Differential Expression
  - Choosing count distribution model: voom vs edgeR
  
# A crash course in `bash`

Pardon the pun

## Introduction

Yesterday we introduced the language `R`, which is heavily used in bioinformatics.
`R` is particularly effective for interacting with and visualising data, as well as performing statistical analyses.
However, in modern bioinformatics `R` is commonly used in the middle to late stage of many analyses.
Today we're going to be interacting with programs and data using the command-line and using the language called `bash`.

We can utilise `bash`in two primary ways:

1. Interactively through the terminal
2. Through a script which manages various stages of an analysis.

Today we will work interactively using the terminal by executing commands and having a look at our alignment data. Before we start getting into our alignments however, we need to go through the basics of `bash` and how we execute commands.

## Setup the directory for today

Just as we've created a new `R Project` for Day 1, let's create a new one for today to make sure we're all in the same place.

- Using the `File` menu at the top left, select `New Project`
- Select `New Directory`
- Select `New Project`
- If you're not already asked to create this project as a subdirectory of `~`, navigate to your home directory using the <kbd>Browse</kbd> button 
- In the `Directory Name` space, enter `Day_2`, then hit the <kbd>Create Project</kbd> button.

This again helps us keep our code organised and is good practice.

## Running `bash` on your VM

All computers running MacOS and Linux have a terminal built-in as part of the standard setup, whilst for Windows there are several options, including `git bash` which also enables use of version control for your scripts.
To keep everything consistent for this practical, we'll use the terminal which is available inside `RStudio`.
Note that even though we're using `RStudio`, we won't be interacting with `R` today as `R` runs interactively in the `Console`.
Instead we'll be using one of the other features provided by `RStudio` to access `bash`

To access this, open `RStudio` as you have for the previous practicals and make sure the `Console` window is visible.
Inside this pane, you will see a **Terminal** Tab so click on this and you will be at an interactive terminal running `bash`.

Historically, `bash` is a replacement for the earlier Bourne Shell, written by Stephen Bourne, so the name is actually a hilarious joke.
We'll explore a few important commands below, and the words *shell* and *bash* will often be used interchangeably with the terminal window.

Although we haven't specifically mentioned this up until now, your virtual machines are actually running the *Ubuntu* flavour of Linux, and we can access these machines by logging in remotely, as well as through the `RStudio` interface which you used yesterday.
Most High-Performance Computing (HPC) systems you use will require a knowledge of Linux so these practicals will give you the basics skills for working in this environment.
Most of the data analysis performed by the Bioinformatics Hub relies on the University of Adelaide HPC for data storage and data processing.

## Finding your way around

Once you're in the `Terminal` section of `RStudio`, you will notice some text describing your computer of the form

```
biotech7005@2019-biotech7005-xx:~/Day_2$
```

The first section of this describes your username (`XXXXXXX`) and the machine `XXXXXXXXX`.
The end of the machine identifier is marked with a colon (`:`).

After the colon, the string (`~/Day_2`) represents your current directory, whilst the dollar sign (`$`) indicates the end of this path & the beginning of where you will type commands.
This is the standard interface for the Bourne-again Shell, or `bash`.

### Where are we?

#### `pwd`

Type the command `pwd` in the terminal then press the <kbd>Enter</kbd> key and you will see the output which describes the current directory you are in.

```bash
pwd
```

The command `pwd` is what we use to __p__rint the current (i.e. __w__orking) __d__irectory.
Even though we are not using `R`, if you have setup the R project like we instructed above this command will probably return the directory. 

```
/home/biotech7005/Day_2
```

Check with your neighbour to see if you get the same thing.
If not, see if you can figure out why.

At the beginning of this section we mentioned that `~/Day_2` represented your current directory, but now our machine is telling us that our directory is `/home/biotech7005/Day_2`.
This raises an important and very useful point.
In `bash` the `~` symbol is a shortcut for the home directory of the current user.
If Dan was logged in, this would be `/home/Dan` whilst if Steve was logged in this would be `/home/Steve`.
As we are all logged on as `biotech7005`, this now stands for `/home/biotech7005`.
(Formally, `~` is  a variable, but we'll deal with variables later.)

Importantly every user with an account on a machine will have their own home directory of the format `/home/username1`, `/home/username2` etc..
Notice that they will all live in the directory `/home` which is actually the parent directory that all users will have a home directory in, as we've just tried to explain.
This can be confusing for many people, so hopefully we'll clear this up in the next section or two.

In the above, the `/home` directory itself began with a slash, i.e. `/`.
On a unix-based system (i.e. MacOS & Linux), the `/` directory is defined to be the root directory of the file system.
Windows users would be more familiar with seeing `C:\` as the root of the computer, and this is an important difference in the two directory structures.
Note also that whilst Windows uses the **backslash** (`\`) to indicate a new directory, a Linux-based system uses the **forward slash** (`/`), or more commonly just referred to simply as "slash", marking another but very important difference between the two.

#### cd
{:.no_toc}

Now we know all about where we are, the next thing we need to do is go somewhere else.
The `bash` command for this is `cd` which we use to **c**hange **d**irectory.
No matter where we are in a file system, we can move up a directory in the hierarchy by using the command

```bash
cd ..
```

The string `..` is the convention for *one directory above*, whilst a single dot represents the current directory.


Enter the above command and notice that the location immediately to the left of the \$ has now changed.
Enter `pwd` again to check this makes sense to you.

If we now enter
```bash
cd ..
```
a couple more times we should be in the root directory of the file system and we will see `/$` at the end of our prompt.
Try this and print the working directory again (`pwd`).
The output should be the root directory given as `/`.

We can change back to our home folder by entering one of either:

```bash
cd ~
```
or

```bash
cd
```

The initial approach taken above to move through the directories used what we refer to as a **relative path**, where each move was made *relative to the current directory*.
Going up one directory will clearly depend on where we are when we execute the command. 

An alternative is to use an **absolute path**.
An **absolute path** on Linux/Mac will always begin with the root directory symbol `/`.

For example, `/foo` would refer to a directory called `foo` in the root directory of the file system (NB: This directory doesn't really exist, it's an example).
In contrast, a **relative path** can begin with either the current directory (indicated by `./`) or a higher-level directory (indicated by `../` as mentioned above).
A subdirectory `foo` of the current directory could thus be specified as `./foo`, whilst a subdirectory of the next higher directory would be specified by `../foo`.

Another common absolute path is the one mentioned right at the start of the session, specified with `~`, which stands for your home directory `/home/biotech7005`, which also starts with a `/`.

We can also move through multiple directories in one command by separating them with the slash `/`.
For example, we could also get to the root directory from our home directory by typing
```bash
cd ../../
```

**Return to your home directory using** `cd`.

In the above steps, this has been exactly the same as clicking through directories in our familiar folder interface that we're all familiar with.
Now we know how to navigate folders using `bash` instead of the GUI.
This is an essential skill when logged into a High Performance Computer (HPC) or a Virtual Machine (VM) as the vast majority of these run using Linux.

### Important!!

*Although we haven't directly discovered it yet, most file systems used on Unix-based systems such as Ubuntu are* **case-sensitive**, whilst **Windows file systems are usually not**.
For example, the command `PWD` is completely different to `pwd` and doesn't actually exist on your (or any) default installation of `bash`.

If `PWD` happened to be the name of a command which has been defined in your shell, you would get completely different results than from the intended `pwd` command.
Most `bash` tools are named using all lower-case, but there are a handful of exceptions.

We can also change into a specific directory by giving the path to the `cd` command using text instead of dots and symbols.
Making sure you're in your home directory we can change back into the Day_2 directory
```bash
cd
cd Day_2
pwd
```

This is where we started the session.

#### Tab auto-completion

In a similar way that `RStudio` offered 'suggestions' when we start typing the name of a function, `bash` has the capacity for `auto-completion` as well.
This will help you avoid a ridiculous number of typos.

If you start typing something bash will complete as far as it can, then will wait for you to complete the path, command or file name.
If it can complete all the way, it will.

Let's see this in action and start becoming keyboard heroes.
Change into your home folder.

```
cd
```

Now to change back into your Day_2 folder, type `cd Pr` without hitting enter.
Instead hit your <kbd>Tab</kbd> key and `bash` will complete as far as it can.
If you have setup your directories correctly, you should see this complete to `cd Day_` which is unfinished.
You should have `Day_1` in your home folder, so `bash` has gone as far as it can.
Now it's up to us to enter the final `2` before hitting <kbd>Enter</kbd>.

When faced with multiple choices, we can also hit the <kbd>Tab</kbd> key twice and `bash` will give us all available alernatives.
Let's see this in action by changing back to our home folder.

```
cd
```

Now type `cd Da` and hit the <kbd>Tab</kbd> key twice and you will be shown all of the alternatives.
You'll still have to type the `2` though.

Another example which will complete all the way for you might be to go up one from your home folder.

```
cd
cd ..
```

Now to get back to your home directory (`/home/biotech7005`) start typing `cd b` followed by the <kbd>Tab</kbd> key.
This should auto-complete for you and will save you making any errors.
This also makes navigating your computer system very fast once you get the hang of it.

Importantly, if tab auto-completion doesn't appear to be working, you've probably made a typo somewhere, or are not where you think you are.
It's a good check for mistakes.


### Looking at the Contents of a Directory

There is another built-in command (`ls`) that we can use to **list** the contents of a directory.
This is a way to get our familiar folder view in the terminal.
Making sure you are in your home directory (`cd ~`), enter the `ls` command as it is and it will print the contents of the current directory.

```bash
ls
```

This is the list of files that we normally see in our traditional folder view that Windows and MacOS show us by default.
We can actually check this output using `RStudio` too, so head to the **Files** tab in the `Files` window.
Click on the Home icon (![home](../R_Practicals/images/home.png)) and look at the folders & files you can see there.
**Do they match the output from `ls`?**
Ask for help if not.

Alternatively, we can specify which directory we wish to view the contents of, **without having to change into that directory**.
Notice **you can't do actually this using your classic GUI folder view**.
We simply type the `ls` command, followed by a space, then the directory we wish to view the contents of.
To look at the contents of the root directory of the file system, we simply add that directory after the command `ls`.

```bash
ls /
```

Here you can see a whole raft of directories which contain the vital information for the computer's operating system.
Among them should be the `/home` directory which is one level above your own home directory, and where the home directories for all users are located on a Linux system.

```bash
cd 
ls Day_1
```

### Creating a New Directory

Now we know how to move around and view the contents of a directory, we should learn how to create a new directory using `bash` instead of the GUI folder view you are used to.
Navigate to your home folder using `bash`.

```
cd ~/Day_2
```

Now we are in a suitable location, let's create a directory called `test`.
To do this we use the `mkdir` command as follows:

```bash
mkdir test
```

You should see this appear in the GUI view, and if you now enter `ls`, you should also see this directory in your output.

Importantly, the `mkdir` command above will only make a directory directly below the one we are currently in as we have used a relative path.
If automating this process via a script it is very important to understand the difference between *absolute* and *relative* paths, as discussed above.

#### How To Not Panic
{:.no_toc}

It's easy for things to go wrong when working in the command-line, but if you've accidentally:

- set something running which you need to exit or
- if you can't see the command prompt, or
- if the terminal is not responsive

there are some simple options for stopping a process & getting you back on track.
Some options to try are:

| Command  | Result |
|:-------- |:------ |
| <kbd>Ctrl</kbd>+<kbd>C</kbd> | Kill the current job |
| <kbd>Ctrl</kbd>+<kbd>D</kbd> | End of input         |
| <kbd>Ctrl</kbd>+<kbd>Z</kbd> | Suspend current job  |

<kbd>Ctrl</kbd>+<kbd>C</kbd> is usually the first port of call when things go wrong.
However, sometimes <kbd>Ctrl</kbd>+<kbd>C</kbd> doesn't work but <kbd>Ctrl</kbd>+<kbd>D</kbd> or <kbd>Ctrl</kbd>+<kbd>Z</kbd> will.

## Redirection Using The Pipe Symbol

Sometimes we need to build up our series of commands & send the results of one to another.
The *pipe* symbol (`|`) is the way we do this & it can literally be taken as placing the output from one command into a pipe & redirecting it somewhere new.
This is where thinking about the output of a command as a *data stream* can be very helpful.
This is a very conventional approach when working in `bash` and was the motivation behind the creation of the `magrittr` package in `R`.

As a simple example, we could take the output from an `ls` command & send it to the pager `less`.
The pager `less` essentially turns the terminal window into a text viewer so we can display text in the terminal window, but with no capacity for us to edit the text, almost like primitive version of Acrobat Reader.

Although we can navigate through the `less` pager using up & down arrows on our keyboards, some helpful shortcuts are:

| Key    | Action |
|:---------- |:------ |
| <kbd>Enter</kbd>    | go down one line |
| <kbd>Spacebar</kbd> | go down one page (i.e. a screenful) |
| <kbd>B</kbd>        | go **b**ackwards one page |
| <kbd><</kbd>        | go to the beginning of the document |
| <kbd>></kbd>        | go to the end of the document |
| <kbd>Q</kbd>        | quit |

For example, lets look at the how we can pipe one command into another

```
ls -lh /usr/bin | less
```

Page through the output (using <kbd>Spacebar</kbd>) until you get bored, then hit `q` to quit.

You can do this with a number of other handy unix tools called `head` and `tail`.
As you can probably work out from the name, they enable you to look at the head (top) or tail (bottom) of a file. 
These commands are especially handy for looking at large files.

```
ls -lh /usr/bin | head

ls -lh /usr/bin | tail
```

You can also use the `-n` parameter to print a certain number of lines


```
ls -lh /usr/bin | head -n 2
```

---

Ok I told you it was going to be a crash course! 
If you're having problems working with the command-line, don't worry there will be plenty of helpers out there to give you some help.
Now lets get into some biology!


## Working with Alignments

### Quality control of alignment data

A fundamental aspect of high-throughput sequencing approaches is the alignment of your input sample to a closely-related reference genome. 
By identifying differences, or genetic variations, between the assembled reference genome and the input sample, we are able to make inferences regarding potential genetic changes that are creating phenotypic differences. 
However, aligning millions, and often billions, of sequence fragments (referred to as "reads") to a specific reference genome is an incredibly complex task, especially in light of repetitive sequences that make it difficult to place certainity on a specific location of each sequence read.

Of course, what happens when we sequence RNA? RNA fragment differ from DNA in that it only contains coding regions of the genome. 
This means we will only see the exons of a gene, with the introns being spliced out after transcription. 
If we are aligning to a genome made of DNA, rather than a transcriptome made of RNA, then we need the ability to align to split sequences across intron-exon boundaries.

So it is extremely important that we have a way of detailing _where_ each read aligned, as well as information as to _how well_ it aligned. 
In this session we're going to get into how we store alignments

### Data setup

Because we're working backwards, we are assuming that we have already aligned our RNA-seq samples to a reference genome. 

Weâ€™ll be working today in the folder `~/Day_2`. Lets change into that directory:

```
cd ~/Day_2
```

Please ensure you use this _exact_ path as any variations will undoubtedly cause you problems & lead to unnecessary confusion.

Now we have our base directory setup for the day, we can place our data in the directory `~/Day_2/data`. 
As you may have seen yesterday, the data that we need is already available in the `~/data` directory in our home area. 
Lets copy all the contents of that directory to our new 

```
cp -r ~/data/Day_2/* ~/Day_2/data/
ls ~/Day_2/data/
```

There should be one directory contained there, called `2_alignedData`.
This contains all the data that (funnily enough) we will be creating tomorrow, but for which we need today.
Within `2_alignedData` we had all the inputs that we need to look at alignments and count data.

```
ls ~/Day_2/data/2_alignedData
```

Let's get stuck into learning about alignment files.

#### What is a SAM file and what's a BAM file?

BAM stands for Binary AlignMent and these are our alignments stored in binary.
There is another type of file called a SAM (Sequence AlignMent) file which is in plain text, but SAM files can become very large and waste our precious storage resources.
BAM files are the exact same files stored in binary format which enables them to be much smaller.
This also has the added benefit of being faster for computers to read & perform operations on, as only humans read plain text.
Computers don't.

To look at the contents of a BAM file, we'll need the tool `samtools` which is one of the most heavily utilised command-line tools in the world of bioinformatics.
`samtools` is used for a number of tasks in high-throughput sequencing analysis, from viewing and converting alignment formats, to generating reports and statistics.
This tool as a series of sub-commands which we can see if we just type `samtools` into our terminal.

```
Program: samtools (Tools for alignments in the SAM format)
Version: 1.9 (using htslib 1.9)

Usage:   samtools <command> [options]

Commands:
  -- Indexing
     dict           create a sequence dictionary file
     faidx          index/extract FASTA
     fqidx          index/extract FASTQ
     index          index alignment

  -- Editing
     calmd          recalculate MD/NM tags and '=' bases
     fixmate        fix mate information
     reheader       replace BAM header
     targetcut      cut fosmid regions (for fosmid pool only)
     addreplacerg   adds or replaces RG tags
     markdup        mark duplicates

  -- File operations
     collate        shuffle and group alignments by name
     cat            concatenate BAMs
     merge          merge sorted alignments
     mpileup        multi-way pileup
     sort           sort alignment file
     split          splits a file by read group
     quickcheck     quickly check if SAM/BAM/CRAM file appears intact
     fastq          converts a BAM to a FASTQ
     fasta          converts a BAM to a FASTA

  -- Statistics
     bedcov         read depth per BED region
     depth          compute the depth
     flagstat       simple stats
     idxstats       BAM index stats
     phase          phase heterozygotes
     stats          generate stats (former bamcheck)

  -- Viewing
     flags          explain BAM flags
     tview          text alignment viewer
     view           SAM<->BAM<->CRAM conversion
     depad          convert padded BAM to unpadded BAM
```

As you can see, each sub-command points to specific tasks that you can do with the program.
The one we'll need at this point is `samtools view`, which enables us to take a BAM file and send it to the screen as plain text so we can read it.
Remember, we can use the pipe `|` to direct the screen to a function call `head`, which gives the first lines of the file.

```
cd ~/Day_2/data/2_alignedData/bam
samtools view [FILE] | head
```

As you can see, there is a tonne of information here set out in columns which are all tab separated.
These contain information about the where and how the read aligned to the reference genome.
The specific information of each field is contained below:


| Field | Name | Meaning |
| ---- | ----- | ------- |
| 1 | QNAME | Query template/pair NAME |
| 2 | FLAG | bitwise FLAG (discussed later) |
| 3 | RNAME | Reference sequence (i.e. chromosome) NAME |
| 4 | POS | 1-based leftmost POSition/coordinate of clipped sequence |
| 5 | MAPQ | MAPping Quality (Phred-scaled) |
| 6 | CIGAR | extended CIGAR string |
| 7 | MRNM | Mate Reference sequence NaMe (`=` if same as RNAME) |
| 8 | MPOS | 1-based Mate POSition |
| 9 | TLEN | inferred Template LENgth (insert size) |
| 10 | SEQ | query SEQuence on the same strand as the reference |
| 11 | QUAL | query QUALity (ASCII-33 gives the Phred base quality) |
| 12 | OPT | variable OPTional fields in the format TAG:VTYPE:VALUE |


Notice that each read is considered to be a *query* in the above descriptions, as we a querying the genome to find out where it probably came from.

Several of these fields contain useful information, so looking the the first few lines, you can see that these reads are mapped in pairs as consecutive entries in the QNAME field are often (but not always) identical.
Most of these fields are self-explanatory, but some require exploration in more detail.
Note that in the following command, each line from the file may wrap around several lines in your terminal.
If this is confusing, just select the first read only by adding the option `-n1` after your call to `head`

```
samtools view SRR945375.skm.trimmedAligned.sortedByCoord.out.bam | head -n1
```

While its not actually output in BAM files, an alignment file has a lot of extra information that is commonly printed at the start of a file.
The `samtools view` command actually hides this from you by default, but it contains some very important information such as the names of all the reference genome sequences, whether the file is sorted or not, and the command that was used to create the file in the first place. 
To see this info we need to add the `-h` flag.

```
samtools view -h SRR945375.skm.trimmedAligned.sortedByCoord.out.bam | head 
```

This is what you should see

```
@HD     VN:1.4  SO:coordinate
@SQ     SN:1    LN:195471971
... <shortened>
@PG     ID:STAR PN:STAR VN:STAR_2.5.3a  CL:STAR   --runThreadN 12   --genomeDir /data/biorefs/reference_genomes/ensembl-release-96/mus_musculus/star   --readFilesIn /data/biohub/2019_SIB/1_trimmedData/fastq/SRR945375.skm.trimmed.fastq.gz      --readFilesCommand gunzip   -c      --outFileNamePrefix /data/biohub/2019_SIB/2_alignedData/bam/SRR945375.skm.trimmed   --outSAMtype BAM   SortedByCoordinate
@CO     user command line: STAR --runThreadN 12 --genomeDir /data/biorefs/reference_genomes/ensembl-release-96/mus_musculus/star --readFilesIn /data/biohub/2019_SIB/1_trimmedData/fastq/SRR945375.skm.trimmed.fastq.gz --readFilesCommand gunzip -c --outFileNamePrefix /data/biohub/2019_SIB/2_alignedData/bam/SRR945375.skm.trimmed --outSAMtype BAM SortedByCoordinate
```

#### Questions
{:.no_toc}


1. *What program was used to align the genome?*
2. *Some common values in the bam file are 99, 147 & 145. Look up the meanings of these values.*



## SAM Flags

These are second field in a sam/bam file and are quite useful pieces of information, however they can be difficult at first look.
Head to http://broadinstitute.github.io/picard/explain-flags.html to see a helpful description, then try clicking on a few combinations to see how the numbers change.
The simplest way to understand these is that it is a bitwise system so that each description heading down the page increases in a binary fashion.
The first has value 1, the second has value 2, the third has value 4 & so on until you reach the final value of 2048.
The integer value contained in this file is the unique sum of whichever attributes the mapping has.
For example, if the read is paired & mapped in a proper pair, but no other attributes are set, the flag field would contain the value 3.

#### Questions
{:.no_toc}


1. *What value could a flag take if the read was 1 - paired; 2 - mapped in a proper pair; 3 - it was the first in the pair \& 4 - the alignment was a supplementary alignment.*
2. *Some common values in the bam file are 99, 147 & 145. Look up the meanings of these values.*
3. *In our very first call to* `samtools` *when we performed our alignments, we used the filter* `-F4`. *Now you understand flags, can you figure out what this was doing?*


Things can easily begin to confuse people once you start searching for specific flags, but if you remember that each attribute is like an individual flag that is either on or off (i.e. it is actually a binary bit with values 0 or 1).
If you searched for flags with the value 1, you wouldn't obtain the alignments with the exact value 1, rather you would obtain the alignments **for which the first flag is set** & these can take a range of values.


Let's try this using the command `samtools view` with the option `-f` to include reads with a flag set and the option `-F` to exclude reads with a specific flag set.
Let's get the first few reads which are mapped in a proper pair, so the flag `2` will be set.

```
cd 2_alignedData/bam
samtools view -f 2 SRR2003569_chI.bam | head
```

Note that none of the flags actually have the value 2, but if you typed the values 99, 147 or 163 into the webpage, you'll see that this flag is set for all of these values.
Similarly if we wanted to extract only the reads which are NOT mapped in a proper pair we would change the option to a upper-case F.

```
samtools view -F 2 SRR2003569_chI.bam | head
```

Again, try entering a few of these sample values into the webpage and you will see that this flag is not set for any of these values.

This can be a very helpful tool for extract subsets of your aligned reads.
For example, we can create a new BAM file with only the reads which were aligned in a proper pair by entering the following command.

```
samtools view -f 2 -bo SRR2003569_chI.bam
ls -lh
```

You can thus pull out highly specific combinations of alignments should you so choose.

## MAPQ

Hopefully the 3rd and 4th fields are self explanatory, as these can be generally interpreted as the chromosome & position in the reference where the sequence aligned.
However, the 5th field contains the `MAPQ` score which indicates how well the read aligned, and how unique each alignment is.
We won't spend much time on this as the values tend to differ between alignment tools, but in general a higher score indicates a better, more unique alignment.


## CIGAR strings

These give useful information about the type of alignment that has been performed on the read.
In the first few reads we called up earlier, most had the value `..M` where `..` is some number.
These are the perfect Matches, where the sequence has aligned exactly.
The other abbreviations in common use are I (insertion), D (deletion) & S(substitution).

### Duplication/Deduplication with Picard

## Sorting Alignments

Before we start calling variants we will need to **sort the alignments**.
The original file will contain alignments in the order they were found in the original fastq file, so sorting arranges them in *genomic order*.

```
mkdir ~/Practical_7/2_alignedData/sorted_bam
cd ~/Practical_7/2_alignedData
samtools sort bam/SRR2003569_chI.bam -o sorted_bam/SRR2003569_chI.bam
```

This helps the variant caller to run the calling algorithm efficiently and prevents additional time to be allocated to going back and forth along the genome. 
This is standard for most NGS downstream programs, such as RNA gene quantification and ChIPseq peak calling.

Once we've sorted our alignments, we usually *index* the file, which allows rapid searching of the file.
Running the following command will create an associated `bai` file which is the index associated with our sorted alignments.

```
samtools index sorted_bam/SRR2003569_chI.bam
```

---
**Note: Additional Filtering**
Ideally, before we start calling variants, there is a level of duplicate filtering that needs to be carried out to ensure accuracy of variant calling and allele frequencies. 
The duplicates we wish to remove are generated during PCR and are not biological in origin, however **we'll skip this step today**.
For future reference, the code you would use to do this is:

```
# Remove duplicates the samtools way
samtools rmdup [SORTED BAM] [SORTED RMDUP BAM]

# Remove duplicates the picard way (which uses Java)
java -jar /path/to/picard/tools/picard.jar MarkDuplicates I=[SORTED BAM] O=[SORTED RMDUP BAM] M=dups.metrics.txt REMOVE_DUPLICATES=true
```

We would probably place these in a new folder called 3_deduplicatedData/bam, however everyone does have their own unique approach to setting up directories.

---


### Assessment of alignment rate and multi-mapping



